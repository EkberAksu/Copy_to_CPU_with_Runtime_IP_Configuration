/*
Copyright 2013-present Barefoot Networks, Inc. 
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header_type cpu_header_t {
    fields {
        device: 8;
        reason: 32;
    }
}

header_type ethernet_t {
    fields {
        dstAddr     : 48;
        srcAddr     : 48;
        etherType   : 16;
    }
}

header_type ipv4_t {
    fields {
        version     : 4;
        ihl         : 4;
        diffserv    : 8;
        ipv4_length : 16;
        id          : 16;
        flags       : 3;
        offset      : 13;
        ttl         : 8;
        protocol    : 8;
        checksum    : 16;
        srcAddr     : 32;
        dstAddr     : 32;
    }
}

header_type tcp_t {
    fields {
        srcPort : 16;
        dstPort : 16;
        seqNo : 32;
        ackNo : 32;
        dataOffset : 4;
        res : 4;
        flags : 8;
        window : 16;
        checksum : 16;
        urgentPtr : 16;
    }
}

header_type ip_meta_t {
    fields {
        ip_reg : 32;
    }
}

header_type intrinsic_metadata_t {
    fields {
        mcast_grp       : 4;
        egress_rid      : 4;
        mcast_hash      : 16;
        lf_field_list   : 32;
    }
}

header cpu_header_t cpu_header;
header ethernet_t ethernet;
header ipv4_t ipv4;
header tcp_t tcp;

metadata ip_meta_t ip_r;
metadata intrinsic_metadata_t intrinsic_metadata;

register my_register {
    width: 32;
    instance_count: 1;
}

parser start {
    return select(current(0, 64)) {
        0 : parse_cpu_header;
        default: parse_ethernet;
    }
}

parser parse_cpu_header {
    extract(cpu_header);
    return parse_ethernet;
}

#define ETHERTYPE_IPV4 0x0800

parser parse_ethernet {
    extract(ethernet);
    return select(ethernet.etherType){
        ETHERTYPE_IPV4  : parse_ipv4;
        default         : ingress;
    }
}

#define IP_PROT_TCP 0x06

parser parse_ipv4 {
    extract(ipv4);
    return select(ipv4.protocol){
        IP_PROT_TCP : parse_tcp;
        default     : ingress;
    }
}

parser parse_tcp {
    extract(tcp);
    return ingress;
}


#define CPU_MIRROR_SESSION_ID                  250

field_list copy_to_cpu_fields {
    standard_metadata;
}

action do_copy_to_cpu() {
    clone_ingress_pkt_to_egress(CPU_MIRROR_SESSION_ID, copy_to_cpu_fields);
}

table copy_to_cpu {
    actions {do_copy_to_cpu;}
    size : 1;
}

action write_to_reg(){
    register_write(my_register, 0, ipv4.dstAddr);
}

table write_reg{
    actions {write_to_reg;}
    size : 32;
}

action read_from_reg(){
    register_read(ip_r.ip_reg, my_register, 0);
}

table read_reg{
    actions {read_from_reg;}
    size : 32;
}

#define CWR_FLAG 0x80
#define ECE_FLAG 0x40
#define URG_FLAG 0x20
#define ACK_FLAG 0x10
#define PSH_FLAG 0x08
#define RST_FLAG 0x04
#define SYN_FLAG 0x02
#define FIN_FLAG 0x01

// CE flags
#define MY_FLAG 0xC0

control ingress {
	if(tcp.flags == MY_FLAG){
		apply(write_reg);
	}
	else{
		apply(read_reg);
	}
	

    if(ipv4.dstAddr == 0x0A000001){
        apply(copy_to_cpu);
    }
}

action _drop() {
    drop();
}

action do_cpu_encap() {
    //add_header(cpu_header);
    modify_field(cpu_header.device, 0);
    modify_field(cpu_header.reason, ip_r.ip_reg);
}

table redirect {
    reads { standard_metadata.instance_type : exact; }
    actions { _drop; do_cpu_encap; }
    size : 40;
}

control egress {
    apply(redirect);

}
